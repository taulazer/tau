using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Newtonsoft.Json;
using osu.Game.Audio;
using osu.Game.Beatmaps;
using osu.Game.Beatmaps.ControlPoints;
using osu.Game.Rulesets.Objects;
using osu.Game.Rulesets.Objects.Types;
using osu.Game.Rulesets.Scoring;

namespace osu.Game.Rulesets.Tau.Objects
{
    public class Slider : AngledTauHitObject, IHasRepeats, IHasOffsetAngle
    {
        public double Duration
        {
            get => Path.Duration;
            set { }
        }

        public double EndTime => StartTime + Duration;

        public bool IsHard { get; set; }

        public override IList<HitSampleInfo> AuxiliarySamples => CreateSlidingSamples().Concat(TailSamples).ToArray();

        public IList<HitSampleInfo> CreateSlidingSamples()
        {
            var slidingSamples = new List<HitSampleInfo>();

            var normalSample = Samples.FirstOrDefault(s => s.Name == HitSampleInfo.HIT_NORMAL);
            if (normalSample != null)
                slidingSamples.Add(normalSample.With("sliderslide"));

            var whistleSample = Samples.FirstOrDefault(s => s.Name == HitSampleInfo.HIT_WHISTLE);
            if (whistleSample != null)
                slidingSamples.Add(whistleSample.With("sliderwhistle"));

            return slidingSamples;
        }

        [JsonIgnore]
        public AngledTauHitObject HeadBeat { get; protected set; }

        [JsonIgnore]
        public PolarSliderPath Path { get; set; }

        /// <summary>
        /// The length of one span of this <see cref="Slider"/>.
        /// </summary>
        public double SpanDuration => Duration / this.SpanCount();

        /// <summary>
        /// Velocity of this <see cref="Slider"/>.
        /// </summary>
        public double Velocity { get; private set; }

        /// <summary>
        /// Spacing between <see cref="SliderTick"/>s of this <see cref="Slider"/>.
        /// </summary>
        public double TickDistance { get; private set; }

        /// <summary>
        /// An extra multiplier that affects the number of <see cref="SliderTick"/>s generated by this <see cref="Slider"/>.
        /// An increase in this value increases <see cref="TickDistance"/>, which reduces the number of ticks generated.
        /// </summary>
        public double TickDistanceMultiplier = 2;

        [JsonIgnore]
        public IList<HitSampleInfo> TailSamples { get; private set; }

        public const int BASE_SCORING_DISTANCE = 100;

        protected override void ApplyDefaultsToSelf(ControlPointInfo controlPointInfo, IBeatmapDifficultyInfo difficulty)
        {
            base.ApplyDefaultsToSelf(controlPointInfo, difficulty);

            TimingControlPoint timingPoint = controlPointInfo.TimingPointAt(StartTime);

            Velocity = BASE_SCORING_DISTANCE / timingPoint.BeatLength;
            TickDistance = BASE_SCORING_DISTANCE / difficulty.SliderTickRate * TickDistanceMultiplier;
        }

        protected override void CreateNestedHitObjects(CancellationToken cancellationToken)
        {
            base.CreateNestedHitObjects(cancellationToken);

            var sliderEvents = SliderEventGenerator.Generate(StartTime, SpanDuration, Velocity, TickDistance, Path.Duration, this.SpanCount(), null, cancellationToken);

            foreach (var e in sliderEvents)
            {
                float currentAngle = Path.AngleAt((float)(e.Time - StartTime));

                switch (e.Type)
                {
                    case SliderEventType.Head:
                        if (IsHard)
                            AddNested(HeadBeat = new SliderHardBeat
                            {
                                ParentSlider = this,
                                StartTime = StartTime,
                                Angle = Path.Nodes[0].Angle
                            });
                        else
                            AddNested(HeadBeat = new SliderHeadBeat
                            {
                                ParentSlider = this,
                                StartTime = StartTime,
                                Angle = Path.Nodes[0].Angle
                            });
                        break;

                    case SliderEventType.Repeat:
                        AddNested(new SliderRepeat
                        {
                            ParentSlider = this,
                            RepeatIndex = e.SpanIndex,
                            StartTime = e.Time,
                            Angle = currentAngle
                        });
                        break;

                    case SliderEventType.Tick:
                        AddNested(new SliderTick()
                        {
                            ParentSlider = this,
                            StartTime = e.Time,
                            Angle = currentAngle
                        });
                        break;
                }
            }

            updateNestedSamples();
        }

        private void updateNestedSamples()
        {
            foreach (var repeat in NestedHitObjects.OfType<SliderRepeat>())
                repeat.Samples = this.GetNodeSamples(repeat.RepeatIndex + 1);

            if (HeadBeat != null)
                HeadBeat.Samples = this.GetNodeSamples(0);

            TailSamples = this.GetNodeSamples(RepeatCount + 1);
        }

        protected override HitWindows CreateHitWindows() => HitWindows.Empty;

        public float GetAbsoluteAngle(SliderNode node) => Angle + node.Angle;

        public float GetOffsetAngle() => Path.EndNode.Angle;

        public int RepeatCount { get; set; }
        public IList<IList<HitSampleInfo>> NodeSamples { get; set; } = new List<IList<HitSampleInfo>>();
    }
}
